
### 信号

> 信号是最古老的方式之一，可以从内核发往一个进程，也可以从一个进程发往另一个进程。如，用户在后台开启一个运行的程序，如果想中断其执行，可以用kill命令把SIGTERM信号发给这个进程。由于信号本身不携带任何信息，这限制了它作为一项通用的进程通信机制。由于信号的特定，所以不用它来作为进程间的直接数据传送，而把它作为非正常情况的处理。Linux的大多数信号类型是供内核使用，只有少数几种可以用作进程之间传送。

Linux系统通过`signal()`将指定的处理函数和信号关联起来。

### 管道

管道就是将一个程序的输出和另一个程序的输入连接起来的单向通道，它是Unix/Linux系统中最古老而应用广泛的一种（特别是shell中）。
  `#ls -l | more`
  例子中建立了一个管道：获取`ls -l`的输出，在将其作为`more`命令的输入，数据从管道的左边流向管道的右边。

当进程创建一个管道的时候，系统内核同时为该进程设立了一对文件句柄（一个流），一个用来从该管道获取数据（read），另一个则用来做向管道的输出（write）。事实上，在Linux系统内核里，每个管道都是用一个`inode`节点来表示的。（当然，你是不会看到这个节点的，它只存在于系统的内核中。）

### 有名管道

> 为了解决管道不能提供非父/子关系进程间通信的缺陷，在管道的基础上发展了有名管道（FIFOs）的概念。尽管管道在 Linux 系统内部是以文件节点（inode）的形式存在的，但是由于其对外的不可见性（“无名”性），我们无法创建新的句柄对其进行访问。而有名管道在 Linux 系统中以一种特殊的设备文件的形式存在于文件系统中。这样它不仅具有了管道的通信功能，也具有了普通文件的优点（可以同时被多个进程共享，可以长期存在等等），有效的解决了管道通信的缺点。

有名管道和管道的操作是相同的，只是要注意，在引用已经存在的有名管道时，首先要用系统中的文件函数来打开它，才能接下来进行其他的操作。由于有名管道的自动阻塞特性，当上面的 server 打开一个有名管道准备读入时，server进程就会被阻塞以等待其他进程（在这里是我们的 client 进程）在有名管道中写入数据。反之亦然。不过，如果需要，我们也可以在打开一个有名管道时使用`O_NONBLOCK`标志来关闭它的自动阻塞特性。

**AT&T 在 UNIX System V 中引入了几种新的进程通讯方式，即消息队列（Message Queues），信号量（semaphores）和共享内存（shared memory），统称为 System V IPC。**在Linux 系统编程中，它们有着广泛的应用。IPC的具体实例在内核中以对象的形式出现，称为IPC对象。

### 消息队列

消息队列在系统内核中是以消息链表的形式出现的。而完成消息链表每个节点结构定义的就是`msg`结构。  
`msgqid_ds`结构被系统内核用来保存消息队列对象有关数据。内核中存在的每个消息队列对象系统都保存一个`msgqid_ds` 结构的数据存放该对象的各种信息。

### 信号量

> 信号量简单的说就是用来控制多个进程对共享资源使用的计数器。它经常被用作一种锁定保护机制，当某个进程在对资源进行操作时阻止其它进程对该资源的访问。需要注意的是，System V 中的信号量对象实际上是信号量的集合（set），它可以包含多个信号量，控制多个共享资源。

### 共享内存

共享内存，简单的说就是被多个进程共享的内存。它在各种进程通信方法中是最快的，因为它是将信息直接映射到内存中，省去了其它IPC方法的中间步骤。

+ 效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。
+ 像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。

方式一：mmap()使得进程键通过映射同一个普通文件实现共享内存。普通文件被映射（不是拷贝）到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。(1)两个进程通过映射普通文件实现共享内存通信；(2)父子进程通过匿名映射实现共享内存。

方式二：进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过shmget获得或创建一个IPC共享内存区域，并返回相应的标识符。内核在保证shmget获得或创建一个共享内存区，初始化该共享内存区相应的shmid_kernel结构注同时，还将在特殊文件系统shm中，创建并打开一个同名文件，并在内存中建立起该文件的相应dentry及inode结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用shmget完成的。

**shmget（）用来获得共享内存区域的ID，如果不存在指定的共享区域就创建相应的区域。shmat()把共享内存区域映射到调用进程的地址空间中去，这样，进程就可以方便地对共享区域进行访问操作。shmdt()调用用来解除进程对共享内存区域的映射。shmctl实现对共享内存区域的控制操作。**

参考：
[共享内存](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html)
[共享内存](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)

### socket

参考：
[管道，消息队列，共享内存对比](https://blog.csdn.net/ttyue_123/article/details/52370676)