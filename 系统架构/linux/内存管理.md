### 操作系统内存管理

+ 内存空间的分配和回收
+ 地址转换：逻辑地址与物理地址
+ 内存空间扩展：利用虚拟存储技术从逻辑上扩充内存

#### 内存连续分配

> 固定分区：简单开销小，但造成内部碎片，分区数目固定不利于并发。
> 动态分区：没有内部碎片，但会造成外部碎片，分配策略相对复杂，分区回收时需要合并，开销大。常用四种分配策略。
> 首次适应不仅简单，通常也是最好和最快的，unix的最初版本使用了该策略；最佳适应法性能是最差的，会留下大量碎片；最坏适应法对大区块切割，很快导致没有可用大区块，性能也差。

+ 首次适应法：按分区地址的先后顺序从头查找，找到符合要求的第一个分区进行分配，但随着分配增多（低端被切割小块），每次查找的时间开销会增大。
+ 循环首次适应法：按分区地址先后次序，每次从上一次分配的分区开始查找。分配和释放性能好，但大区块不易保留。
+ 最佳适应法：空闲分区按容量递增形成链表，找到第一个满足的空闲分区。
+ 最坏适应法：空闲分区按容量递减形成链表，找到第一个满足的空闲分区，即最大分区。

#### 伙伴系统

> 固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一种折衷方案。

伙伴系统规定，无论是已分配分区或未分配分区，其大小均为2的k次幂，不同大小的空闲分区形成各自的空闲分区链表。当需要为进程分配一个长度为n的存储空间时:

1. 首先计算一个i 值，使 2^(i－1) < n ≤ 2^i；
2. 然后在空闲分区大小为2^i的空闲分区,若找到，即把该空闲分区分配给进程；
3. 否则，表明长度为2^i的空闲分区已经耗尽，则在分区大小为2^(i＋1)的空闲分区链表查找；
4. 若存在 2^(i＋1)的一个空闲分区，则把该空闲分区分为相等的两个分区，**这两个分区称为一对伙伴**，其中的一个分区用于配，而把另一个加入分区大小为2^i的空闲分区链表中。

#### 内存不连续分配

在当前的操作系统中，普遍采用的是基于分页和分段机制的虚拟内存机制，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。

> 分页
> 分段

分页管理的方式是从计算机的角度设计考虑的，以提高内存的利用率，提升计算机的性能，且分页通过硬件机制实现，对用户透明；而分段管理方式的提出则是考虑用户和程序员，以满足方便程序、信息保护和共享、动态增长及动态链接等多方面的需要。

结合以上两种方式产生段页式管理，作业的地址空间首先被分成若干个逻辑段，然后再将每一段分成若干个固定的页。这样对内存的管理仍然和分页管理一样。此时作业的逻辑地址分三部分：段号，页号，页内偏移量。

参考：
[深入理解Linux内存管理](https://blog.csdn.net/gatieme/article/details/52384965)