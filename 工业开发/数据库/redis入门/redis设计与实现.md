# redis

## outline

数据结构和对象，单机数据库的实现，多级数据库的实现，独立功能的实现

## 数据结构和对象

+ 五种对象类型：字符串，集合，列表，哈希，有序集合
+ 八种底层数据结构：long, sds(raw), embstr, linkedlist, ziplist, skiplist, hashtable, intset
+ 对象的五种基本属性：type,encoding,ptr,refcount,lru。
+ 每种对象类型底层至少能使用两种不同的数据结构实现，提供灵活高效的选择。

+ REDIS_STING: REDIS_ENCODIND_INT, REDIS_ENCODING_EMBSTR, REDIS_ENCODING_RAW
+ REDIS_LIST: REDIS_ENCODING_LINKEDLIST, REDIS_ENCODING_ZIPLIST
+ REDIS_HASE: REDIS_ENCODING_HT, REDIS_ENCODING_ZIPLIST
+ REDIS_SET: REDIS_ENCODING_HT, REDIS_ENCODING_INSET
+ REDIS_ZSET: REDIS_ENCODING_ZIPLIST, REDIS_ENCODING_SKIPLIST

为什么整数集合只升级不降级？

为什么Redis不共享包含字符串的对象？

## 数据库

实现原理（crud），持久化，事件，客户端，服务端

redis是键值对数据库，每个键都是一个字符串对象，每个值都是五种对象之一。

1.键空间操作：基本操作和维护操作：命中记录，最后使用时间，脏记录，脏计数，**通知**。

2.生存时间：expires字典（过期字典）保存所有键的过期时间。键是指针，值是long long整数。

3.过期删除策略：

+ 定时删除，设置定时器，内存友好cpu不用好，主动删除
+ 惰性删除，读取时检查是否过期，cpu友好内存不友好，被动删除
+ 定期删除，每个一段时间检查一次，间隔小则占用cpu，间隔大则浪费内存

**redis采用惰性删除和定期删除结合的方式。**惰性删除是内置策略，定期删除可配置，默认1秒10次。
`expireIfNeeded` `activeExpireCycle` **定期删除应控制好执行的频率和时长。**

## RDB持久化

1.服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成为止。保存RDB文件可以采用`SAVE()`或`BGSAVE()`前者会阻塞服务器进程，后者通过子进程执行。

2.redis允许用户通过设置save选项，让服务器每个一段时间自动执行一次BGSAVE命令。`save 900 1`, `save 300 10` `save 60 10000`默认900秒1次修改，300秒10次修改，60秒10000次修改则自动保存。`saveparams`数组。

3.dirty计数器：距离上一次保存后数据库进行多少次修改；
lastsave熟悉：记录上一次保存的时间
redis的周期性操作函数serverCron默认每100毫秒执行一次，用于对正在运行的服务器进行维护，包括检查是否满足保存条件。

4.RDB结构：REDIS字符标志，db_version, databases, EOF, check_sum
  databases结构：SELECTDB， db_number, key_value_pairs
  键值对结构：EXPIRETIME_MS标志, ms, TYPE, key, value

5.自带RDB文件检查工具：redis-check-dump。

## AOF持久化（append only file）

1.AOF持久化是通过保存Redis服务器执行的写命令来记录数据库状态。被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为redis的命令请求协议是纯文本文件，所以可以直接打开查看。

2.将写命令以协议格式追加到aof_buf缓冲区末尾。在服务器每次结束一个事件循环之前，调用flushAppendOnlyFile函数考虑是否将aof_buf缓冲区的内容写入AOF文件。
`appendsync:always, everysec, no`设置同步。

> 文件写入和同步：为了提高文件的写入效率，现代操作系统中，当用户调用ｗrite函数将数据写入文件时，操作系统会将写入数据暂时保存在内存缓冲区里，等缓冲区填满或超时再将缓冲区数据写入磁盘。可能出现安全问题，系统停机会导致缓冲区数据丢失。当然系统会提供接口函数实现强制刷新。
> always模式每次写入都同步，效率最慢，但安全，只会丢失一次事件数据。everysec为默认模式，足够快，而且停机只会丢失一秒的数据。

3.redis命令执行只能在客户端上下文中执行，所以还原时创建一个伪客户端一次执行写命令。

4.AOF文件体积会随事件膨胀，为了解决问价膨胀问题，redis提供AOF文件重写功能。
原理：无需对现有的AOF文件进行分析，而是**直接从数据库读取键的现有值，再用一条命令去记录键值对即可**，替代之前的多条命令。当然当集合或者列表元素过多时，将使用多条命令记录键值对。`REDIS_AOF_REWRITE_ITEMS_PER_CMD = 64`

5.redis将AOF重写程序放到**子进程**执行，使用子进程而不是线程，子进程带有数据副本，可以避免使用锁的情况，保证数据安全。

6.为了保证数据一致，在执行重写子进程期间，写命令会同时追加到AOF缓冲区和AOF重写缓冲区。**重写执行完成后，将AOF重写缓冲区写到新的AOF文件并重命名覆盖原来的AOF文件**。

## 事件

redis服务器是一个事件驱动程序，服务器需要处理两类事件：文件事件和时间事件。
> redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器通过监听并处理这些事件来完成一系列网络通信操作。
> 时间事件：服务器对定时操作的抽象。
> 文件事件处理器是基于reactor模式实现的网络通信程序。

### 文件事件处理器

1.文件事件处理器以单线程模式运行，但通过I/O多路复用来监听多个套接字。既实现高性能的网络通信模型，又可以很好地与redis服务器中其他同样以单线程运行的模块进行衔接，保持了**redis内部单线程设计的简单性**。

2.套接字-->IO多路复用程序-->文件事件分配器-->不同的事件处理器

3.redis的IO多路复用底层实现是可以替换的，可以选择select， epoll, evport和kqueue等。

4.事件类型，当套接字可读（客户端write或者close或者connect），套接字产生AE_READABLE事件；当套接字可写时，产生AE_READBLE事件。如果同意套接字同时产生两种事件，则前者优先处理。

5.连接应答处理器，命令请求处理器，命令回复处理器。

### 时间事件

定时事件：让程序在指定时间之后执行，周期事件：让程序每隔一段时间执行一次。（id, when, timeproc）

保存时间事件的链表为无序链表。

serverCron函数：定期对redis自身的资源和状态进程调整，确保服务器长期稳定。

+ 更新各类统计信息，如时间，内存占用，数据库占用；
+ 清理过期键值对；
+ 关闭和清理连接失效的客户端；
+ 尝试进行持久化；
+ 如果服务器是主服务器，进行定期同步；
+ 如果是集群模式，对集群进行定期同步和连接测试。

### 调度执行

+ aeApiPoll函数的最大阻塞时间由到达最接近当前时间的**时间事件**决定。这样即可避免服务器对时间事件的频繁轮询，也可确保函数不会阻塞过长时间。
+ 对文件事件和时间事件的处理都是**同步，有序，原子**执行的，不会中断事件处理。事件处理器尽量减少阻塞时间，有需要时主动让出执行权，从而降低事件极饥饿的可能性。
+ 因为事件不可抢占，所以时间事件的处理时间通常比设置的稍晚一些。

### redis服务器

命令名字不分大小写。

对于时间精度要求不高的功能，直接使用redisserver结构中的时间缓存，对于时间精度要求高的则执行系统调用获取时间，这样可以减少系统调用的次数。

**servercron**

## 多机数据库

主从复制，sentinel，集群原理

## 主从复制

1.同步与命令传播：从服务器主动执行同步操作，主服务器修改后通过命令传播给从服务器。

2.流程：

## sentinel系统

对比：

+ 端口不同
+ sentinel是一个特殊的redis服务器，运行sentinel模式，该模式下命令表中只有七种命令：`ping`, `sentinel`, `info`, `subscribe`, `unsubscribe`, `psubscribe`, `punsubscribe`。
+ 功能调整

**功能**：sentinel系统监视多个主服务器以及主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时（限时），自动将下线主服务器下属的某个从服务器升级为新的主服务器，然后有新的主服务器继续处理命令请求。已下线的服务器继续被监视，重新上线后再替换为~~主服务器~~。主要包括：**发布订阅**，**服务器内部的文件事件处理器和时间事件处理器**。

1.**启动**：初始化服务器->将普通代码替换为sentinel专用代码->初始化sentinel状态->根据配置文件初始化监视主服务器列表->创建连向主服务器的网络连接。

sentinel会创建两个连向主服务器的**异步**网络连接，一个是命令连接，一个是**订阅连接**，专门用于订阅主服务器的_sentinel:_hell0频道。

sentinel如何获取服务器信息？
sentinel默认每10秒一次向主服务器发送INFO命令，通过分析回复来获取主服务器的当前信息，回复中既包括主服务器的信息也包括从服务器的信息。主从服务器信息结构含有不同的标志SRI_MASTER和SRI_SLAVE。sentinel也会也10秒一次的频率向从服务器发送INFO命令，获得类似的回复。**每个服务器对应一个实例结构**，保存相应信息。

sentinel通过命令连接向服务器的频道发送信息宣告自己的存在（默认频率每秒两次），通过订阅连接从服务器获取信息。发送到服务器频道的信息会被广播到订阅该服务器频道的所有sentinel，因此一个sentinel可以通过分析接收到的频道信息来获知其他sentinel的存在，并通过发送频道信息让其他sentinel知道自己的存在，从而使得监视同一个主服务器的多个sentinel可以自动发现对方，并且他们之间会相互建立命令连接。

sentinel之间不会建立订阅连接，因为sentinel需要通过接收服务器发来的频道信息发现未知的新的sentinel，所以才需要建立订阅连接，而相互已知的sentinel只要使用命令连接进行通信即可。

sentinel以默认每秒一次的频率与建立命令连接的服务器和其他sentinel发送ping命令判断对方是否在线。当主服务器连续返回无效回复超过定时，则标记为**主观离线**。每个sentinel设置的主观下线时长选项的**作用范围**是主服务器，从服务器和监视这个主服务器的其他sentinel。**多个sentinel设置的主观下线时长可能不同**。当sentinel将一个主服务器判断为主观下线后，它会向同样监视该主服务器的其他sentinel询问，当从其他sentinel接收到足够（根据配置设置）的已下线（此处为主观还是客观？？？）判断后，sentinel将服务器判定为**客观下线**，并对主服务器进行**故障迁移**。

选举领头sentinel？？？

如果进行故障迁移？
1.选出新的主服务器：由领头sentinel筛选，先去除下线断线的，最近没有成功通信的等，保证剩余的从服务器保存的数据比较新，然后根据优先级选取，同优先级则根据复制偏移量选取，如果都一样则选取ID小的。
2.修改从服务器的复制目标
3.将旧的主服务器修改为从服务器：因为旧的主服务器以下线，所以修改设置保存在sentinel中旧主服务器对应的实例结构里。

## 集群

1.开启集群模式，添加节点，通过`clusterNode`结构保存节点信息，通过`clusterLink`结构保存连接信息，`clusterState`结构记录当前节点视角下集群当前的状态。

redisClient结构和clusterLink结构都有自己的套接字信息和输入，输出缓冲区，二者的区别在于，redisClient结构中的套接字和缓冲区用于连接客户端，而clusterLink结构用于连接节点。

2.redis集群通过分片的方式保存数据库中的键值对：**集群的整个数据库分为16384个槽**（slot），当数据库中**所有**的槽都有节点在处理时，集群处于上线状态，如果任一个槽没有得到处理，那么数据库处于下线状态。

槽指派：`cluster addslots`,通过bitarray记录，节点之间互相传播自己的槽指派信息，并存储下来。`clusterState`中记录了每个槽的指派节点。

客户端向节点发送的键值对操作不是由该节点处理时怎么办？
计算keyslot：CRC16(key) & 16383，**集群模式下隐藏moved错误直接跳转，单机模式下显示moved错误，不进行跳转**。

节点数据库的实现？？？
节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机redis服务器则没有这个限制。

3.重新分片？？？
redis集群的重新分片工作由`redis-trib`负责。ASK错误，在槽迁移过程中访问已迁移的键，实现类似moved的跳转。注意moved（永久跳转）和ask（单次跳转）错误的区别。

4.ASK（是否带有ASKING标志），moved在槽迁移过程中的使用？P272

5.集群通信的类型：`meet` `ping` `pong` `fail` `publish`

参考：<https://www.cnblogs.com/kismetv/p/9853040.html>

## 独立功能

发布订阅，事务，lua脚本，排序，二进制，慢查询日志，监视器

### 订阅

1.命令：publish, subscribe(unsubscribe), psubscribe(punsubscribe)

2.频道订阅和模式订阅都是通过链表存储起来的

3.客户端发布的消息会向频道订阅和模式订阅的客户端发送。一个客户端可能收到同一条信息的频道订阅和模式订阅两条内容相同的信息。

4.pubsub channels：查看服务器当前被订阅的频道
  pubsub numsub：返回频道的订阅者数量
  pubsub numpat：返回服务器当前被订阅的模式数量

### 事务

1.通过队列实现，`multi`开始，接着将输入的命令会添加到事务中，最后由`exec`提交给服务器执行。

2.`watch`是一种乐观锁，在`exec`前监视任意数量的数据库键，在exec执行是判断是否有键被修改。redis数据库中保存一个`watched_keys`字典（列表），所有对数据库修改的命令在执行后都会调动`multi.c/touchWatchKey`函数对字典进行检查，将被修改键的客户端的`REDIS_DIRTY_CAS`标志打开，表示事务安全性被破坏，这时候事务会被拒绝执行。

3.ACID性质

+ 原子性：执行期间遇到错误将继续执行，直到结束，并且不支持事务回滚机制（rollback）。redis作者认为rollback的复杂功能与redis的简单高效设计不符，并且执行错误是由编程错误产生，通常只会出现在开发中，很少出现在实际生产环境。
+ 一致性：如果数据库在执行事务之前是一致的，那么事务执行之后，不管事务是否执行成功，数据也是一致的。“一致”指数据符合数据库本身的要求，不包含非法或无效的错误数据。
+ 隔离性：redis单线程，且执行期间不进行中断。
+ 耐久性：根据持久化的设置，无持久化，RDB持久化和AOF持久化。

### 排序

### 慢查询日志

redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。配置选项：`slowlog-log-slower-than`执行时间阈值，`slowlog-max-len`设置保存的日志数量。

### 监视器

客户端可以执行`monitor`指令将自己变为一个监视器，客户端的`redis_monitor`标志被打开，实时地接收并打印服务器当前处理的命令请求的相关信息。服务器将多有监视器记录在monitors链表中，每次处理命令请求前，调用`replicationFeedMonitors`函数，由该函数将信息发送给各个监视器。

## etc

1.read more books about redis

2.murmurhash

3.hash负载因子的合理范围

4.c++的智能指针是基于引用计数实现内存回收，redis的对象系统也是基于引用计数进行内存回收。

5.redis如何保持性能？

6.reactor模式 事件驱动

7.慢查询