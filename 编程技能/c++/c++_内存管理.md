# c++内存管理

参考：
[深入理解Linux内存管理](https://blog.csdn.net/gatieme/article/details/52384965)

## 内存模型

1. 段页式
2. buddy,slab
3. 内存池

## 堆栈

### 堆栈的区别

1. 管理方式不同；栈申请和释放由编译器管理，而堆的管理由程序员控制，所有容易产生内存泄露
2. 空间大小不同；栈一般很小，可以设置1M左右，堆内存基本没有限制。
3. 能否产生碎片不同；栈不会产生内存碎片，而堆内存由于频繁的new/delete会产生内存碎片。
4. 生长方向不同；栈从上往下高地址向低地址生产，堆由低地址向高地址生长
5. 分配方式不同；栈由编译器分配，堆由程序员动态分配
6. 分配效率不同；堆比栈的分配效率低得多

### 堆栈的大小

栈的空间一般比较小（约1Mb），堆空间比较大（可以达到几个Gb）。
计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。Stack的最顶端一般会留存在CPU registers 和 cache 中。遇到频繁但是层次不多的函数调用，可以利用高速 cache。大块的内存会破坏这种优化。

### 堆的内存分配策略

内存池：例如SGI STL中的二级内存分配策略

参考：<https://blog.csdn.net/xiaorenwuzyh/article/details/44516467>

### 堆栈存的内容

堆：new
栈：函数进栈时第一个进栈的是**主函数的下一条指令地址**，然后时函数的各个参数（大部分编译器从右到左入栈），然后是函数中的局部变量。

## buddy,slab

### slab着色

    假设cpu的缓存一行为32字节,cpu包含 512 个缓存行（缓存大小16K ）。假设对象 A,B均为32字节，且 A 的地址从 0 开始， B 的地址从 16K 开始，则根据组相联或直接相联映射方式（全相联方式很少使用）， A,B 对象很可能映射到缓存的第0行，此时，如果CPU 交替的访问 A,B 各 50 次，每一次访问 缓存的第 0 行都失效，从而需要从内存传送数据。而 slab 着色就是为解决该问题产生的，不同的颜色代表了不同的起始对象偏移量，对于 B 对象，如果将其位置偏移向右偏移 32字节 ，则其可能会被映射到 cache 的第 1 行上，这样交替的访问 A,B 各 50 次，只需要 2 次内存访问即可。   这里的偏移量就代表了 slab 着色中的一种颜色，不同的颜色代表了不同的偏移量，尽量使得不同的对象的对应到不同的硬件高速缓存行上，以最大限度的提高效率。实际的情况比上面的例子要复杂得多， slab 的着色还要考虑内存对齐等因素，以及 slab内未用字节的大小，只有当未用字节数足够大时，着色才起作用。

参考：
[Linux内存管理Buddy和Slab](https://zhuanlan.zhihu.com/p/36140017)

## 内存操作错误及对策

1. 内存分配未成功，却使用了它。编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。

2. 内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值。

3. 内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。

4. 忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。

5. 释放了内存却继续使用它。

摘自：<https://www.itcodemonkey.com/article/11588.html>

## 内存碎片

### linux伙伴系统及内存碎片处理

把所有的空闲页框分组为11个块链表，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，对1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB）。

依据可移动性组织页：
> 文件系统也有碎片，该领域的碎片问题主要通过碎片合并工具解决。它们分析文件系统，重新排序已分配存储块，从而建立较大的连续存储区。理论上，该方法对物理内存也是可能的，但由于许多物理内存页不能移动到任意位置，阻碍了该方法的实施。因此，内核的方法是反碎片(anti-fragmentation), 即试图从最初开始尽可能防止碎片。
>
> 为每页添加移动属性：不可移动页（内核内存），可移动页（用户空间），可回收页（缓存）。采取策略例如：不可移动的页不能位于可移动内存区的中间等。

从buddy申请内存页，如果找不到合适的页，则会进行两步调整内存的工作（满足一定条件才执行），compact和reclaim。前者是为了整合碎片，以得到更大的连续内存；后者是回收不一定必须占用内存的缓冲内存。
buddy,slab
参考：
[经典面试题之内存碎片](https://cloud.tencent.com/developer/article/1084794)
[linux是如何避免内存碎片的](https://blog.csdn.net/aurorayqz/article/details/79671785)
[伙伴系统是如何避免碎片的](https://blog.csdn.net/gatieme/article/details/52694362#t13)
[深入理解Linux内存管理](https://blog.csdn.net/gatieme/article/details/52384965)

2.高速缓存slab
3.内存池，sgi stl二级分配策略

## 内存泄露

### 如何避免

+ 尽量避免在堆上分配内存。
+ 申请的内存手动释放，成对使用（可能忘记，异常等）。
+ 善用RAII机制管理资源（堆上分配内存时，同时在栈上分配一个对象，让栈上的对象对堆上的对象进行封装，用时通过在栈对象的析构函数中释放堆内存的方式，将栈对象的生命周期和堆内存进行绑定），如智能指针，减少裸指针的使用。

RAII:“资源获取就是初始化”技术，它是由C++之父Bjarne Stroustrup提出的一种资源管理方法，它的核心思想是将资源抽象为类，用局部对象来表示资源（内存是资源的一种），把管理资源的任务转化为管理局部对象的任务。

### 如何检测

+ 静态检测
+ 动态检测

参考：
[Linux平台下调试c++内存泄露的方法](https://www.ibm.com/developerworks/cn/linux/l-cn-memleak/index.html)
[c++如何避免内存泄露](https://zhuanlan.zhihu.com/p/51898119)