
### const

1. 修饰变量，说明该变量不可被改变；
2. 修饰指针，分为指向常量的指针和指针常量；
3. 常量引用，经常用于形参类型，避免函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量；

### static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main()函数运行之前分配空间；
2. 修饰全局变量，依然存在静态全局区，但作用域由项目变为文件作用域；
3. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才使用。在多人开发项目时，可防止与他人命名重复；
4. 修饰成员变量，
5. 修饰成员函数，static函数内不能访问非静态成员。

### this指针

1. 每一个非静态成员函数都有一个隐藏的this指针，指向正在被该成员函数操作的对象， 隐含声明为ClassName* const this
2. 当一个对象调用成员函数是，编译程序先将对象的地址赋值给this指针，然后调用成员函数，这样每次成员函数存钱数据成员时，隐含使用this指针。
3. this并不是常规变量，而是个右值，所以取this的地址。
4. 经常显式引用this指针：
  1. 为实现对象的链式引用
  2. 为避免为同一对象进行赋值
  3. 实现一些数据结构，如list

### mutable

用来修饰const实例的部分可变的数据成员，所以`mutable`只能修饰类的数据成员。

参考：<https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/>

### inline内联函数

+ 相当于把内联函数里面的内容写在调用内联函数处；
+ 相当于不用执行进入函数的步骤，直接执行函数体；
+ 相当于宏，却比宏多了类型检查，真正具有函数特性；
+ 不能包含循环、递归、switch 等复杂操作；
+ 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 编译器对 inline 函数的处理步骤

+ 将 inline 函数体复制到 inline 函数调用点处；
+ 为所用 inline 函数中的局部变量分配内存空间；
+ 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
+ 如果inline函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优点

+ 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
+ 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
+ **在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能**。
+ 内联函数在运行时可调试，而宏定义不可以。

#### 缺点

+ 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
+ inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
+ 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

### assert

断言，是宏，而非函数。assert 宏的原型定义在<assert.h>（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。

### pragma pack(n)

> 设定结构体、联合以及类成员变量以 n 字节方式对齐#pragma pack(n) 使用

```c++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```

### volatile

+ volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
+ volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）

### union

### explicit

+ explicit 修饰构造函数时，可以防止隐式转换和复制初始化
+ explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外

```c++
struct B
{
  explicit B(int) {}
  explicit operator bool() const { return true; }
};

void doB(B b) {}

B b1(1);        // OK：直接初始化
B b2 = 1;       // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
B b3{ 1 };        // OK：直接列表初始化
B b4 = { 1 };   // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
B b5 = (B)1;    // OK：允许 static_cast 的显式转换
doB(1);     // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按转换
bool b6(b1);    // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按转换
bool b7 = b1;   // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
```

### friend友员类和友员函数

+ 能访问私有成员
+ 破坏封装性
+ 友元关系不可传递
+ 友元关系的单向性
+ 友元声明的形式及数量不受限制

### ::范围解析

### enum

```c++
// color 可为 red （值 0 ）、 yellow （值 1 ）、 green （值 20 ）或 blue （值 21 ）
enum color
{
    red,
    yellow,
    green = 20,
    blue
};

color col = blue;
cout << col << endl;
```

### decltype

### `#ifndef, #define, #endif`的作用

[防止头文件被重复包含：头文件全局变量可能重复定义](https://www.cnblogs.com/challenger-vip/p/3386819.html)

预处理功能包括三种：宏定义，文件包含，条件编译，以上为条件编译