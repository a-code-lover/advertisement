<!-- ---
title: "《C++ primer》选读"
date: 2017-10-02T09:43:48+08:00
lastmod: 2019-03-01T15:43:48+08:00
draft: false
tags: [reading]
categories: [C++]
author: "Archillieus"
autoCollapseToc: true

#menu:
#  main:
#    parent: "docs"
#    weight: 1
#    #name: "hi"
#    #url: "https://gohugo.io"
--- -->

## 第二章：变量与类型

### 类型系统

> + 一般float和double分别是7，16个有效位。  
> + 类型char实际上会表现为signed char还是unsigned char，由编译器决定。  
> + c++的设计原则之一是尽可能接近硬件。。。  
> + 避免无法预知和依赖于实现环境的行为。
> + 运算符运算之前会先将运算参数转换为同样的类型。
> + 指定字面值的类型。
> + 对象是具有某种数据类型的内存空间。
> + constexpr变量？？？

[类型选择](../rsc/类型选择.png)  
[不同类型系统的语言](https://www.zhihu.com/question/19918532)  
[常用语言的类型系统分类](../rsc/类型.png)  
[不同类型系统的可移植问题](https://blog.csdn.net/u014659656/article/details/46779381)  
[c++类型转换](https://blog.csdn.net/zdplife/article/details/50922456)  
[c++类型转换](https://segmentfault.com/a/1190000016582440)  

### 类型占用内存

[int占几个字节？](https://blog.csdn.net/u014492609/article/details/38067599)  
[CPU与操作系统约束](https://blog.csdn.net/championhengyi/article/details/80458060)  
[vs为什么没有64位版本](https://www.zhihu.com/question/20370633)  
[数据模型](https://www.cnblogs.com/lsgxeva/p/7614856.html)

### 变量

1.默认初始化  
(1)**内置类型**如果在函数体外,默认初始化为0; 如果**在函数体内,则不被初始化**,（严格来说，编译器并未被要求检查此类错误，大多数编译器会对部分使用未初始化变量的行为给出警告，使用未初始化的变量会带来不可预估的结果）。  
(2)每个类各自决定其初始化的方式。  
(3)连续赋值：赋值号是从右到左的，（赋值返回引用？？），(x=y)=3。  

2.列表初始化

3.声明和定义
c++支持分离式编译，允许将一个程序拆分为多个文件分别单独编译，为了支持分离编译，c++将声明和定义区别。声明使得名字为程序所知，一个文件如何想使用别处定义的名字，就必须包含对这个名字的声明。而定义负责创建与名字关联的实体。`extern int i;//声明i而非定义i`，`int j;//声明并定义j`，`external dooble pi = 3.14;//定义`。可以多次声明，只能一次定义。

### 复合类型（指针和引用）

类型修饰符（*&）不过是**声明符**的一部分罢了，而非基本类型的一部分。**基本类型+类型修饰符+变量名**
引用必须初始化，无法重新绑定到新的对象。
使用未初始化的指针会引起的运行错误，`void*`能做的比较有限：和别的指针比较，作为函数的输入输出(**制作模板**)，或者赋值给另一个void指针。

### const

```c++
  int i = 0;
  int *const p1 = &i;  //顶层const, 不能修改p1
  const int ci = 42;  //顶层const，不能修改ci
  const int *p2 = &ci;  //底层const，允许修改p2
  const int *const p3 = p2;
  const int &r = ci;  //用于声明引用的const都是底层const
```

### 类型处理

1.通过`typedef`或`using =`进行别名声明，使得复杂的类型名称简单化。  
2.auto类型声明符能让编辑器替我们分析表达式的类型，但推断出来的类型和初始值类型并不完全相同，auto会忽略顶层的const，留下底层的const；也可能去掉引用。。。  
3.decltype类型指示符，作用是选择并返回操作数的数据类型，编译器分析表达式并得到类型，但**不会执行表达式或函数**。  
如果表达式是**解引用**或者**有双层括号**，则结果是引用类型。  

### 头文件保护符

利用`#ifndef`, `#define`, `#endif`, `#ifdef`这几个预处理变量，避免头文件被多次重复包含。头文件即使（目前还）没有被包含到其他文件中，也应该设置保护符，习惯性加上即可，不必在意是否需要。

## 第三章：字符串，vector，数组

> + 头文件不应包含using声明，因为头文件的内容会拷贝到所有引用它的文件中，可能产生名字冲突。
> + c++内置类型如数组的实现与硬件密切相关，灵活性稍显不足。

### string

1.直接初始化和拷贝初始化:`string s = "abc";`为拷贝初始化, 拷贝初始化的三种形式`s = str;`, `s = string("abc");`, `s = "abc";`。
2.字符串读取：`getline(cin, line);`
3.由于string兼容很多c字符串的操作，所以string的成员函数经常支持下表形式的操作，如`find()`, `replace()`等，但algorithm库中都是标准接口，使用标准迭代器。

### vector

1.vector能容纳绝大多数对象作为元素，但由于引用不是对象，不存在包含引用的vector。同样，数组的元素也是对象，所以不存在引用的数组。  
2.初始化：

+ `vector<int> nums(10);`nums有十个元素，每个为零， `vector<int> nums{10};`nums有一个元素。
+ vector<string> v("hi"); //报错
+ vector<string> v{"hi"}; //列表初始化
+ vector<string> v{10}; //十个元素
+ vector<string> v{10, "hi"}; // 十个hi

3.通过下标访问不存在的元素的行为非常常见，而且会产生非常严重的后果。所谓的**缓冲区溢出**指的就是这类错误。大多数常见的错误都是源于缓存区溢出。
4.end()为“尾后”迭代器。

### 数组

1.因为编译时编译器必须知道数组的大小，所以数组的维度必须是**常量表达式**。如果不指定数组的维度，那么数组大小由显示初始化的维度决定。  
2.字符数组末尾有一个空字符`\0`。  
3.不能直接用一个数组来初始化另一个数组，也不能将一个数组拷贝给另一个数组。（编译器扩展可能会会支持，但不是标准。）  
4.对于复杂数组的声明，如果没有括号，则按照从右到左理解（默认情况下，**类型修饰符从右到左依次绑定**）。如果有括号，则按照**从内到外**理解，如下：  

```c++
  int *ptrs[10]; // ptrs是一个含有十个整数指针的数组
  int &refs[10]; // 错误：不存在引用的数组
  int (*parray) [10]; //parray指向一个含有十个整数的数组
  int (&RefArray) [10]; // RefArray引用一个含有十个整数的数组
  
  int a[10] = {1,2,3};
  cout << a << endl;
  cout << &a << endl;
  auto b(a);
  cout << b[1] << endl;
  decltype(a) c = {1,2,3};
  int (*d) [10] = &a;
  cout << *d << endl;
  cout << (*d)[1] << endl; //输出a[1]
  cout << d << endl; //输出a
  cout << d[0] << endl; //输出a
  cout << d[1] << endl; //输出&a[1]
  int *a1 = &a[1];
  cout << a1 << endl;
  cout << a1[1] << endl;
  cout << a1[-1] << endl; //下标竟然可以是负数
  a = a1; //报错，不能给数组赋值
  b = a1; //b为指针
  c = a1; //报错，不能给数组赋值
```

5.c++11标准提供了begin()和end()函数，返回数组的头指针和尾后指针，定义在iterator头文件中。

```c++
  int nums[] = {1,2,3};
  int *beg = begin(nums);
  int *last = end(nums);
```

6.内置类型的下标运算符所用的索引值不是无符号类型，这和vector，string不一样。
7.不要在c++中使用c风格字符串，极易引起程序漏洞，是诸多安全问题的根本原因。

## 第四章：表达式

+ 重载运算符，其包括运算变量的类型和返回值的类型，都是有该运算符决定的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。
+ 简单归纳：当一个对象被用作右值的时候，用的是对象的纸（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
+ 求余运算符的对象必须是整数，否则报错。`21 % -5； //结果为1`
+ 除非必须，否则不使用递增递减运算符的后置版本。一是更符合编程初衷，二是性能。`*iter++;`等价于`*(iter++)`。
+ `sizeof`运算符返回表达式或者类型所占的字节数。

### 求值顺序

1.有四种运算符明确规定了运算对象的求值顺序，为`&&`，`||`，`?:`, `,`四种。  
2.**对于没有指定执行顺序的运算符来说，如果表达式指向并修改同一个对象，将会引发错误并产生未定义的行为。**  
3.`int i = f1() * f2();`，其中`f1`，`f2`一定在乘法之前调用，但两个函数的执行顺序是不确定的。  
4.`int i = 0; cout << i << " " << ++i << endl; //未定义`，编译器可能先求`i`再求`++i`，也可能先求`++i`再求`i`，甚至有其他完全不同的操作。因为此表达式的行为不可预知，所以不论编译器生成什么的代码程序都是错误的。其他例子，如`*iter = toupper(*iter++); //错误，未定义行为`。  
5.`*++iter`合法，先执行递增再解引用。  

### 运算符

1.sizeof运算符

### 类型转换

1.大多数用到数组的表达式中，数组自动转换成数组首元素的指针；当数组作为decltype关键字的参数，或者作为**取地址符**，sizeof及typeid等运算符的运算对象时，上述转换不会发生。  
2.虽然有时候不得不使用强制类型转换，但这种方法本质上是非常危险的。  

+ static_cast<type>()任何具有明确定义的类型，只要不包含底层const，都可以使用。类型损失的警告信息会被关闭。
+ const_cast只能改变运算对象的底层const。
+ reinterpret_cast通常为运算对象的位模式提供较底层的重新解释。使用这种转换是非常危险的，本质上依赖于机器，要想安全使用必须对涉及的类型和编译器实现转换的过程非常了解。
+ 建议：避免使用强制类型转换。

3.旧式的强制类型转换，如果转换为const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reinterpret_cast类似的功能。一旦转换过程出现问题，追踪更加困难。  
`type(expr); //函数形式`  
`(type)expr; //c语言风格`  

## 第五章：语句（控制流）

+ 逗号表示空语句，使用空语句应该加上注释，从而使读者注意到有意的忽略。
+ 在异常发生期间正常执行“清理”工作的程序被称为异常安全的代码。当异常发生时只是简单终止程序，这样也不用担心异常安全的问题，但要保证处理异常并继续执行，就必须注意。

### switch

1.从匹配的第一条语句往后执行到最后，因此break语句非常重要。
2.建议在最后一个case和default标签后面写case，保持风格一致，避免添加新的case漏掉。

## 第六章：函数

+ 通过**调用运算符**执行函数，调用运算符是一对括号，作用于一个表达式（函数或者指向函数的指针），调用表达式的类型就是函数的返回类型。主调函数，被调函数。
+ 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。
+ 局部静态对象：在函数中定义static对象，在第一次经过时定义初始化，直到程序结束才销毁。
+ 参数赋值是从左到右，所有默认实参必须在右边，让那些经常使用默认值的形参出现在后面。
+ 内联可以避免函数调用的开销；一般来说，内联机制用于优化规模小、流程直接、频繁调用的函数。
+ constexpr函数，规定：函数的返回类型和参数类型都是字面值，函数体内有且只有一条return语句，隐式指定为内联。
+ constexpr函数不一定返回常量表达式，把内联和constexpr函数放在头文件中

### 参数传递

1.值传递：指针形参，熟悉c的程序员经常使用指针类型的形参访问函数外部的对象，在c++中，**建议使用引用类型的形参代替指针**。  
2.拷贝大的类类型或者容器对象比较低效，甚至有的类类型（包括io在内）根本不支持拷贝操作。当某种类型不支持拷贝时，只能通过引用形参访问。  
3.如果函数无需修改引用形参的值，最好将其声明为**常量引用**。  
4.使用引用形参返回额外信息（好像我经常这么做，但java不支持）。  
5.用实参初始话形参时会**忽略底层const**，所以也不能利用顶层const实现重载。  
6.形参的初始化方式和变量的初始化形式一样，**可以使用非常量初始化一个底层const对象，但是反过来不行**。底层const出现在指针和引用中。  

```c++
  int i = 42;
  const int *cp = &i;  //correct
  int *p = cp;  //wrong
  const int &r = i;  //correct
  int &r2 = r; //wrong
```

7.尽量使用常量引用，把函数不会改变的形参定义为普通引用是一种比较常见的错误，一是误导调用者函数可以改变形参的值，二是限制函数所接受的实参类型。
8.数组形参：数组有两个特殊的性质，一是不能拷贝，所以无法以值传递的方式使用数组形参；二是数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是数组的指针，函数并不知道数组的长度。管理数组形参有三种常用技术：

+ 使用数组本身带有结束标记来指定长度，如c风格字符串。
+ 使用标准库规范，传递数组首指针和尾后指针。
+ 显示传递一个表示数组大小的形参
+ 另外：可以使用数组引用形参

```c++
  void print(const int*);  //以下三者等价
  void print(const int[]);
  void print(const int[10]); //这里的维度是我们期望的维度，实际不一定

  void print(const char *cp);
  void print(const int *begin, const int *end);
  void print(const int ia[], size_t size);
  vodi print(const (&arr)[10]);
```

### 可变参数

1.如果所有实参类型相同，c++11提供`initializer_list`，initializer_list对象的元素永远是常量；  
2.如果实参类型不同，c++11提供可变参数模板；  
3.省略符是一种特殊的形参类型，可以传递可变参数的形参，但一般只用于与c函数交互的借口。  

### 返回类型

1.不要返回局部变量的引用和指针；  
2.调用一个返回引用的函数得到的是左值，其他返回类型得到的是右值。  
3.列表初始化返回值。  
4.返回数组指针  

```c++
  Type (*function(parameter_list)) [dimension] //返回数组指针的函数形式,数组维度是必须的。
  auto func(int i) -> int(*)[10]； //在本应返回的地方写auto,通过尾置返回类型。
  //或者使用decltype声明返回类型
```

### 函数重载

1.一个拥有**顶层const**的形参无法和另一个没有顶层const的形参区别开来，不能重载；如果形参是某种类型的指针或引用，**底层const**可以实现重载。  
2.**什么时候使用重载？？？**  
3.const_cast在重载函数的情景最有用。  

```c++
  const string& shorterString（const string &s1, const string &s2) {
    return s1.size() < s2.size() ? s1 : s2;
  }
  string& shorterString(string &s1, string $s2) {
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    // auto会忽略引用
    return const_cast<string&>(r);
  }
```

4.重载匹配

+ 编译器找到最佳匹配，并生成调用该函数的代码；
+ 无匹配，报错；
+ 多个匹配但不存在最佳匹配，报错；

### 函数指针

```c++
  bool lengthCompare(const string&, const string&);
  //该函数的类型是：bool(const string&, const string&);
  bool (*pf)(const string&, const string&);

  pf = lengthCompare; //二者等价，类似数组指针
  pf = &lengthcompare;

  bool b1 = lengthCompare(s1, s2); //以下为等价调用
  bool b2 = pf(s1, s2);
  bool b3 = (*pf)(s1, s2);

  //Func和Func2是函数类型
  typedef bool Func(const string&, const string&);
  typedef decltype(lengthCompare) Func2;
  //FuncP和FuncP2是函数指针类型
  typedef bool(*FuncP)(const string&, const string&);
  typedef decltype(lengthCompare) *FunctionP2;
```

## 第七章：类

> + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。
> + 抽象，是指从众多的事务中抽取出具有共同的、本质性的特征作为一个整体。是共同特质的集合形式。封装，是将通过抽象所得到的数据信息和操作进行结合，使其形成一个有机的整体。对内执行操作，对外隐藏细节和数据信息。两者的区别，在于抽象是一种思维方式，而封装则是一种基于抽象性的操作方法。我们通过抽象所得到数据信息及其功能，以封装的技术将其重新聚合，形成一个新的聚合体，也就是类。或者说，两者是合作者的关系，如果没有抽象，封装就无从谈起，如果没有封装，抽象也将没有意义。
> + 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此，成员函数体可以随意使用类中的其他成员而无需在意他们的出现次序。
> + 可以将类的声明和定义分离开来（前向声明，此时类是不完全类型）。在创建类的对象之前，类必须定义，否则无法计算内存。

### const成员函数

1.默认情况下，this的类型是**指向类类型非常量版本的常量指针**。例如在Sales_data成员函数中，this的类型是Sales_data *const。默认情况下我们不能把this绑定到一个常量对象上，这使得我们不能在一个常量对象上调用普通的成员函数。  
2.c++允许把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针，这样的成员函数称为常量成员函数。  
3.常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。  

### 类的定义

1.在类的外部定义成员函数时，定义必须和声明匹配。  
2.定义类相关的**非成员函数**，一些**辅助函数**尽管定义的操作从概念上是属于类的接口的组成部分，但实际不属于类。应当将他们的声明和类的声明放在同一个头文件，这样用户只需引入一个头文件就可以使用接口。  

```c++
  //定义一个返回this对象的函数
  Sales_data& Sales_data::combine(const Sales_data &rhs) {
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
  }
```

### 构造函数

1.只有当类没有任何构造函数的情况下，编译器才会自动生成默认构造函数，又称为**合成的默认构造函数**。  
2.某些类**不能依赖**合成的默认构造函数，必须定义自己的默认构造函数，有三个原因。  

+ 一旦我们定义了一些其他的构造函数，除非我们再定义一个默认的构造函数，否则将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。
+ 对于某些类来说，合成的默认构造函数可能执行错误的操作。如在块中的内置类型或复合类型被默认初始化时，它们的值未定义。如果类包含内置类型或者复合类型的成员，则**只有当这些成员全都被赋予类内初始值时，这个类才适合使用合成的默认构造函数。**
+ 有时候编译器不能为某些类合成默认的构造函数。

3.通过在参数列表后面使用`=default`来要求编译器生成构造函数。  
4.类内初始值，构造函数初始值列表，在类的外部定义构造函数。**初始值列表->类内初始值->默认初始化**  
5.拷贝、赋值和析构，如果不自主定义，则**编译器会合成默认版本**。一般来说，编译器生成的版本将对每个成员执行拷贝，赋值和销毁操作。**某些类不能依赖于合成的版本**。  
6.构造函数的初始值有时必不可少，例如当成员是const或者引用时，必须通过初始值列表初始化。  
7.**在很多类中**，初始化和赋值关系到底层效率。  
8.成员的初始化顺序与它们**在类定义中的出现顺序一致**，与初始值列表的顺序无关。建议二者顺序一致。  
9.c++11标准添加**委托构造函数**。  
10.如果构造函数只接受**一个实参**，则它实际定义了转换为此类类型的**隐式转换机制**。隐式转换机制只允许**一步类类型转换**，这种隐式转换可以通过添加`explicit`限制。所以explicit关键字只对单个参数有效。当然explicit无法限制显式转换。  

### 访问控制

1.使用class和struct定义类唯一的区别就是默认的访问权限。  
2.如果类想把一个函数作为它的友员，只需在类内添加一条以`friend`关键字开始的函数声明。  
3.类内声明友员仅仅指定访问权限，还必须在类外再专门对函数进行声明。为了是友员对类的用户可见，通常把友员的声明（类外）和类的声明放在同一个头文件。  
4.可以通过`mutable`关键字修改类常量的某些可变数据成员。  

### 友员

1.如果类想把一个函数作为它的友员，只需在类内添加一条以`friend`关键字开始的函数声明。  
2.类之间的友员关系  
3.另成员函数作为友员：此时必须注意类之间的声明的定义顺序。  
4.友员同意遵守：必须先声明在使用。  

### 静态成员

1.静态函数只能访问静态成员，非静态函数既能访问非静态成员，也能访问静态成员。  
2.对于类成员来说，static关键字只出现在类内部的**声明语句**。  
3.一般来说，不能在类的内部初始化静态成员，相反必须在类的**外部定义和初始化每个静态成员**，一旦定义就存在程序的整个声明周期。**static constexpr 可以类内初始化**。  
4.要想确保对象只定义一次，最好的方法是将静态数据成员的定义和其他非内联函数的定义放在同一个文件。  
5.关于**static const**??? **constexpr**???  

## 第八章：IO库

+ c++语言不直接处理输入输出，而是通过定义在标准库中的类型类处理IO。支持从设备读写数据，设备包括文件，console，以及一些内存IO，即从string读写数据。
+ iostream, fstream, sstream

### IO类

+ cin, 一个istream对象，从标准输入读取数据。
+ cout，一个ostream对象，向标准输出写入数据。
+ `>>`运算符，用来从一个istream对象读取数据。
+ `<<`运算符，用来向一个ostream对象写入数据。

1.IO对象无拷贝和赋值。  
2.条件状态，IO操作一个与生俱来的问题是可能发生错误。最简单的做法是将它**作为一个条件使用**。此外，标准库定义了一组函数来查询标志位：如good, bad, fail, eof等， 同时流对象也提供了管理状态位的方法，如rdstate，setstate。  
3.管理输出缓冲区，由于设备的写操作可能很耗时，缓冲机制允许操作系统将多个输出操作合并为单一的设备写操作，可以带来很大的性能提升。缓冲在多个情况下刷新，  

+ 程序正常结束；
+ 缓冲区满，需要刷新后续数据才能写入；
+ 使用操纵符，如endl，ends，flush；
+ 可以使用操纵符unitbuf设置流的内部状态；
+ 输出流可能关联其他流，当读写被关联的流时，关联到的流缓冲区刷新。如默认下cin和cerr都关联cout，因此读cin或者写cerr会导致cout刷新。

4.如果想每次输出操作都刷新缓冲，可以使用unitbuf操纵符，它告诉流接下来每次写操作后都执行flush操作。`cout << unitbuf; //设置刷新` `cout << nounitbuf; //关闭设置`  
5.如果程序崩溃，输出缓冲区不会刷新。 
6.通过`tie()`实现输入流和输出流绑定。  
7.通过`std::ios::in/out/binary`，通过ios域下的标志设置读写的**mode**。  

### 文件输入输出

1.当我们想读写一个文件时，可以定义一个文件对象，并将对象与文件关联起来。每个文件流对象都定义了一个名为`open`的成员函数，它完成一些系统相关的操作，来定位给定的文件，并**视情况打开为读或写操作**。

```c++
  ifstream in(ifile); //如果提供文件名则open自动调用
  ofstream out;
  out.open(ifile + ".copy"); //通过open函数关联文件
```

2.一个已经打开的文件流调用open会失败，必须先关闭关联的文件再打开新的文件。当一个fstream对象被销毁时，close会自动调用。

3.每个流都有一个关联的文件模式，用来指出如何使用文件。

+ in 以读方式打开
+ out 以写方式打开
+ app 每次写操作前均定位到文件末尾
+ ate 打开文件后立即定位到文件末尾
+ trunc 截断文件
+ binary 以二级制的方式进行IO

ifstream默认使用in模式，ofstream**默认使用out模式和截断**。

### string流

1.可以通过istringstream对象处理格式化的字符串。

## 第九章：顺序容器

+ 新的标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代c++程序应该使用标准库，而不是原始的数据结构，如内置的数组。
+ 除非你有很好的理由使用其他容器，否则使用vector。
+ 如果顺序容器的元素类型支持默认构造，那么可以只提供一个容器大小的参数，如果没有默认构造函数，除了容器大小，须指定一个显式的初始值。
+ 顺序容器提供赋值运算`assign`，不适用于关联容器和array。`assign(num, value);` `assign(first, last)`
+ 赋值运算导致左边容器内部的迭代器，指针，引用失效，`swap`操作不会(会交换迭代器)。
+ 除array外，swap不对任何元素执行拷贝，删除或插入操作，因此可以保证常数时间完成。对于array, swap操作会真换元素。**统一使用非成员版本的swap是一个好习惯**。
+ 容器的元素是拷贝。
+ **string类型提供额外接受c风格字符串的操作**。

### 操作

```c++
  //返回指向插入元素的迭代器
  c.insert(p, t);
  c.insert(p, n, t);
  c.insert(p, b, e);
  c.insert(p, il);

  //在c的末尾构造一个Sales_data对象
  //使用三个参数的构造函数
  c.emplace_back("978-123444", 25, 15.9);
  //错误：没有接受三个参数的push_backa版本
  c.push_back("978-123444", 25, 15.9);
  //正确：创建临时对象在拷贝
  c.push_back(Sales_data("978-123444", 25, 15.9));
  //使用默认构造函数
  c.emplace_back();

  //返回删除后的一个元素的迭代器,删除操作不检查参数的合法性
  c.erase(p);
  c.erase(b,e);
  c.clear();
```

### 访问

访问成员函数返回的是引用，下标运算符越界时，编译器并不提供检查。使用at，越界时会抛出异常。

### 容量

`reserve`小于当前容量是不会退回内存空间，具体内存扩展依赖实现。`resize`只改变元素数目，不是容量，不能用来减少内存空间。`shrink_to_fit`要求vector,string,deque退回内存，但具体实现可能选择忽略。`size`为保存元素个数，`capacity`为不重新分配内存的情况下最多可存几个元素。分配扩展基本原则：确**保用push_back向vector添加元素的操作具有高效率**。

### 适配器：stack, queue, priority_queue

每个适配器都定义两个构造函数：
`stack<int> stk(deq); //从dep拷贝元素到stk`  
`stack<string, vector<string>> str_stk2(svec); //默认stack和queue用deque实现，可以指定用vector实现，初始化保存svec的元素`

## 第十章：泛型算法（generic）

+ 标准库容器定义的操作集合惊人的小。标准库并未给每个容器添加大量功能，而是提供一组算法，这些算法大多数独立于任何特定的容器。它们是通用的或者泛型的。
+ 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。
+ 算法永远不会执行容器的操作：算法永远不会改变容器大小。

### 基本

1.只读算法

```c++
  //由于string定义了+运算符，所以可以调用accumulate拼接字符串
  string sum = accumulate(v.cbegin(), v.cend(), string(""));
  //字符串字面值的类型是const char*?
  string sum = accumulate(v.cbegin(), v.cend(), ""); //错误：const char*没有定义+运算符

```

对于只读而不改变元素的算法，通常最好使用cbegin()和cend()。
那些只接受一个单一迭代器表示第二个序列的算法，都假定第二个序列至少和第一个序列一样长。**有些算法接受三个迭代器参数，有的接受四个迭代器参数。确保算法不会访问第二个序列中不存在的元素是程序员的责任。**

2.写容器元素

```c++
  vector<int> vec;
  //灾难：修改vec中10个不存在的元素
  fill_n(vec.begin(), 10, 0);
  //正确：使用插入迭代器，back_insert等价于push_back
  fill_n(back_inserter(vec), 10, 0);
```

一些算法接受一个迭代器之处一个单独的目的位置，向目的位置**写入数据**的算法假定目的位置足够大，能容纳写入的元素。**注意成员函数和泛型算法的区别：不修改容器大小**。

```c++
  auto ret = copy(begin(a1), end(a1), a2); //把a1的内容拷贝给a2，确保a2大小至少大于a1
  replace(ilst.begin(), ilst.end(), 0, 42); //将所有0改为42，可以使用replace_copy
```

3.重排元素

```c++
  sort(words.begin(), words.end());
  auto end_unique = unique(words.begin(), words.end()); //算法不执行容器的操作
  words.erase(end_unique, words.end()); //调用成员方法实现真正删除
```

### 定制

一元谓词（unary predicate）：只接受一个参数和二元谓词（binary predicate):接受两个参数。

1.lambda(不限谓词)
`[capture list](parameter list) -> return type {function body} //其中捕获列表和函数体是必须的`

lambda通过将局部变量包含到捕获列表来指出将会使用这些变量。
`find_if`, `for_each`, `sort`等。

2.值捕获和引用捕获

类似参数传递，变量的捕获可以是值或引用。与参数不同，被捕获的变量的值是在lambda创建时拷贝（**默认拷贝**），而不是调用时拷贝。
引用捕获与返回引用有着相同的问题和限制，必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，函数执行完就不存在了。**引用捕获有时是必要的**，如接受ostream的引用。
**建议：尽量保持变量捕获简单化，尽量少捕获，避免潜在的捕获导致的问题。**

3.隐式捕获

**指定编译器推断捕获列表，`&`告诉编译器采用捕获引用方式，`=`采用值捕获方式。**
**如果混合使用隐式和显式，一个元素必须指定隐式的方式，且后面的捕获方式必须都和隐式的不同。**
使用`mutable`关键字，可以修改捕获变量的值。

4.如果不指定返回类型，编译器会自己推断，如果推断的类型与需要的返回类型不符，则会编译报错。

5.**参数绑定**

对于只有在一两个地方使用的简单函数，lambda表达式是最有用的。如果lambda表达式的捕获列表为空，通常可以用函数代替它。对于捕获局部变量的lambda，用函数替换就不那么容易（**谓词数量问题**）。标准库提供`bind`函数(函数适配器)，进行**参数列表的适应**。

```c++
  //_n占位符定义在placeholders命名空间中
  using namespace std::placeholders;
  //bind会将g(_1, _2)映射为f(a,b,_2,c,_1)
  auto g = bind(f, a, b, _2, c, _1);
  //参数重排
  sort(words.begin(), words.end(), isShorter);
  sort(words.begin(), words.end(), bind(isShorter, _2, _1));
  //使用标准库ref函数拷贝引用
  for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

默认下，bind的那些不占位的参数使用拷贝的形式，但与lambda类似，有时希望使用引用或者对象无法拷贝，此时必须使用`ref`标准库函数（functional中）。

### 其他迭代器

+ 插入迭代器：这些迭代器被绑定到容器上，用来向容器插入元素；
+ 流迭代器：绑定到输入或者输出流上，用来遍历所关联的IO流；
+ 反向迭代器：向后移动，除forward_list之外的标准库容器均有反向迭代器；
+ 移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动他们。

1.插入迭代器
back_inserter(c)：创建使用push_back的迭代器；
front_inserter(c)：创建使用push_front的迭代器；
inserter(c, iter)：创建使用insert的迭代器；

`copy(lst.cbegin(), lst.cend(), front_inserter(lst2);`
`copy(lst.cbegin(), lst.cend(), inserter(lst2, lst2.begin()));`

2.反向迭代器

`sort(vec.begin(), vec.end());` `sort(vec.rbegin(), vec.rend());`迭代器必须支持递减操作才能定义反向迭代器，所以forward_list和流迭代器没有反向。

迭代器与反向迭代器之间转换：转换后指向的不是同一个位置，二是相邻的位置。
`list<int>::iterator iter(riter.base());`
`list<int>::reverse_iterator riter(iter);`

### 泛型算法结构

+ 输入迭代器：只读，不写；单遍遍历，只能递增；
+ 输出迭代器：只写，不读；单遍遍历，只能递增；
+ 前向迭代器：可读写，多遍遍历，只能递增；
+ 双向迭代器：可读写，多遍遍历，可递增递减；
+ 随机访问迭代器：可读写，多遍遍历，支持迭代器所有操作。

**任何算法的最基本的特性是它要求其迭代器提供哪些操作。**c++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，`find`算法在序列上一遍扫描，对元素只读，因此至少需要输入迭代器；`replace`函数需要一对迭代器，至少是前向迭代器。`sort`算法要求随机访问迭代器。**对向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告信息**。  

算法的形参模式大体分为四种：  
`alg(beg, end, other args);`  
`alg(beg, end, dest, other);`  
`alg(beg, end, beg2, other);`  
`alg(beg, end, beg2, end2, otqiher);`  

命名规范：

+ 一些算法使用重载的形式传递一个谓词，`unique(beg, end);` `unique(beg, end, cmp);`
+ _if版本, `find(beg, end, val);` `find(beg, end, pred);`
+ _copy版本, `reverse(beg, end);` `reverse(beg, end, dest);`

### 特定容器算法

由于list和forward_list的链式结构，使用通用算法的代价很高，应该**优先使用成员函数版本的算法**。

## 第11章：关联容器

关联容器对其关键字有一些限制。对于有序容器，**关键字类型必须定义元素比较的方法**。默认情况下，标准库使用关键字类型的`<`运算符来比较两个关键字。

```c++
  bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
    return lhs.isbn() < rhs.isbn();
  }
  multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
```

标准库类型pair，定义在头文件utility中。`pair<T1, T2> p; p = {v1, v2}; p = make_pair(v1, v2); p.first; p.second;`

### 关联容器操作

1.类型：key_type, mapped_type, value_type
2.可以通过迭代器遍历map或set（有序的按字典序），但**不能通过迭代器修改关键字的值**，迭代器是const的。

```c++
  c.insert(v);
  c.emplace(args);
  c.insert(b, e);
  c.insert(il);
  c.insert(p, v); //从迭代器p开始搜索新元素的存储位置
  c.insert(p, args);

  c.erase(k);
  c.erase(p);
  c.erase(b, e);

  c[k]; //返回关键字为k的元素，不存在就添加并初始化
  c.at[k]; //返回关键字为k的元素，不存在则抛出异常
```

3.对于mutimap和mutiset，如果`lower_bound`和`upper_bound`返回相同的迭代器，则关键字不存在。直接调用`equal_range`，返回迭代器pair。如果未找到，则pair两个迭代器都指向关键字的插入位置。

4.使用无需容器通常更简单，通常也会有更好的性能。

### 无序关联容器

有序关联容器底层是RBTree，无序关联容器底层是hashmap。无序容器对关键字的要求：默认情况下，无序容器使用关键字类型的`==`运算符比较元素，并使用一个`hash<key_type>`类型的对象生成哈希值。所以为了使用无序容器的自定义类型版本，必须提供==运算符和哈希计算函数。

```c++
  size_t hasher(){};
  bool eqOp() {};
  using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
  SD_multiset bookstore(42, hasher, eqOp);
```

## 第12章：动态内存

### 智能指针

1.新的标准库提供两种智能指针类型来管理动态对象：`shared_ptr`允许多个指针指向同一个对象；`unique_ptr`则独占指向的对象；`weak_ptr`的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。三种类型都定义在`memory`中。

2.默认初始化的智能指针中保存着一个空指针，最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。

```c++
  shared_ptr<string> p1 = make_shared<string>(10, 'a');
  shared_ptr<string> p2(p1);
  p1.use_count(); //返回计数，可能很慢，主要用于计数
  p1.get(); //返回p1中保存的指针，小心使用
```

3.使用**计数器**还是其他数据结构记录引用数量，完全由标准库的具体实现决定。当引用计数为0，则销毁对象并释放内存。
4.如果**将shared_ptr存放在容器中**，而后不再需要部分元素，要记得erase删除不再需要的元素。

### 直接管理内存

1.使用内置指针管理动态对象，生命期直到被释放时为止。返回指向动态内存的指针的函数给调用者增加负担，调用者必须记得释放内存。

三个常见问题：

+ 忘记delete内存
+ 使用已经释放掉的对象
+ 同一块内存释放两次

2.delete后指针变成**空悬指针**（dangling pointer），即指向一块曾经保存数据对象但现在已经失效的内存的指针。如果需要保留指针，可以在delete后将指针赋值为nullptr。在实际系统中，查找指向相同内存的所有指针异常困难。

3.不要混用普通指针和智能指针

```c++
  int *x(new int(1000));
  process(x);  //错误：不能将int*转换为shared_ptr<int>
  process(shared_ptr<int>(x)); //合法，但内存会被释放
  int j = *x; // 未定义的：x是一个空悬指针

  p = new int(1024); //错误：不能将一个指针赋值给shared_ptr
  p.reset(new int(1024)); //正确：p指向一个新对象
```

4.get用来将指针的权限传递给代码，只有确定代码不会delete指针的情况下才可以使用。
5.相对于使用普通指针，使用智能指针能更好应对代码异常错误时资源正确释放。

### 智能指针陷阱

+ 不使用相同的内置指针初始化（或reset）多个智能指针；
+ 不delete get()返回的指针；
+ 不使用get()初始化或reset另一个智能指针；
+ 如果使用get()返回的指针，记得最后一个智能指针销毁后，指针无效；
+ 如果使用智能指针管理的不是new分配的内存，记得传递给它一个删除器。

### unique_ptr

1.定义一个unique_ptr时，需要将其绑定到一个new返回的指针，必须采用直接初始化的形式；不支持普通的拷贝或赋值操作，但可以通过release或reset将指针的所有权从一个（非const）unique_ptr转移到另一个unique_ptr。编译器的早版本包含auto_ptr，目前仍包含兼容，但应该使用uniqu_ptr。

```c++
  unique_ptr<int> p1(new int(42));
  unique_ptr<int> p2(p1.release());
  unique_ptr<int> p3(new int(43));
  p3.reset(p2.release());

  p2.release(); //错误：p2不会释放内存，而且我们丢失了指针
  auto p = p2.release(); //正确，但必须记得delete(p)
```

2.可以拷贝和赋值一个将要被销毁的unique_ptr，最常见的例子是从函数返回一个unique_ptr。

```c++
  unique_ptr<int> clone(int p) {
    return unique_ptr<int>(new int(p));
  }
```

3.unique_ptr默认情况下用delete释放对象，我们可以重载默认的删除器。
`unique_ptr<objT, delT> p(new objT, fcn);`

### [weak_ptr](https://blog.csdn.net/VonSdite/article/details/81556647)

1.主要作用是打破shared_ptr的循环引用。  
2.不会增加shared_ptr的计数，不支持`*`和`->`，但可以通过`lock()`接口返回shared_ptr，所有weak_ptr会随着最后一个shared_ptr的销毁一同被销毁。  

## 动态数组

### new和数组

1.`int *pa = new int[10];` new分配要求数量的对象并返回指向第一个对象的指针。“动态数组”有些误导，当用new分配一个数组时，**实际上得到的是一个元素类型的指针，而不是一个数组类型**，所以不支持begin，end，下标等操作。  
2.**动态分配一个空数组是合法的**。  
3.释放动态数组，`delete [] pa;`必须在指针前加`[]`，否则未定义。  

### allocator类

1.`new`分配内存创建对象，`delete`析构对象释放内存，allocator类将内存分配和对象构造分离(会增加一定开销)。

```c++
  allocator<T> a;
  auto p = a.allocate(n); //p为首元素指针
  a.deallocate(p, n);
  a.construct(p, args);
  a.destroy(p);
```

2.拷贝和填充未初始化内存的算法

```c++
  uninitialized_copy(b,e,b2); //将迭代器b到e的对象拷到b2指定的内存
  uninitialized_copy_n(b,n,b2);
  uninitialized_fill(b,e,t); //在b到e指定的内存范围构造对象值为t
  uninitialized_fill_n(b,n,t);
```

## 第15章：面向对象程序设计

抽象，封装，继承，多态

在c++中，当我们使用基类的引用或指针调用一个虚函数时将发生**动态绑定**，有时称**运行时绑定**。

什么是动态绑定？
在继承关系中，由于。。。