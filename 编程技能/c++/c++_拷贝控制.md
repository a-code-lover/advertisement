## 拷贝控制

+ 析构函数
+ 拷贝构造函数
+ 拷贝赋值函数
+ 移动构造函数
+ 移动赋值函数

在定义c++类时，拷贝控制部分是必须，如果用户没有给出自定义的实现，那么编辑器会生成默认的版本，问题是这些默认的行为很可能不是我们想要的。

```c++
class MyStr {
private:
  string myName;
public:
  MyStr(){}
  MyStr(string str):myName(str){
    cout << "直接初始化" << endl;
  }
  MyStr(const MyStr& ms) { // 参数必须为`const MyStr&`,写`ＭyStr&`报错
    std::cout << "拷贝构造" << endl;
    myName = ms.get();
  }
  MyStr& operator=(const MyStr& ms) {
    std::cout << "拷贝赋值" << endl;
    if (this != &ms)
      myName = ms.get();
    return *this;
  }
  string get() const{ //注意const
    return myName;
  }
};

int main()
{
  MyStr a("mike"); //直接初始化
  MyStr b(a); // 拷贝构造
  a = b; // 拷贝赋值
  string str = "john";
  MyStr c = str; // 直接初始化，编译器优化
  return 0;
}
```

### 拷贝构造函数

+ 拷贝构造函数在几种情况下都会隐式使用，通常不应该是`explicit`的。
+ 拷贝构造函数第一个参数必须是引用，几乎总是const引用。
+ 合成拷贝构造函数直接对成员变量拷贝赋值，属于浅拷贝。
+ 使用`=default;`显示要求编译器生成默认版本；类内使用`=default；`是内联的，类外使用则不是内联。
+ 使用`=delete;`通知编译器我们不希望定义这些成员，此时编译器不会合成；旧版本通过定义为`private`，但内部和友员仍可使用，这样是不理想的；析构函数不能删除。

```c++
string dots(10, '.');    //直接初始化
string s(dots);          //直接初始化
string s2 = dots;        //拷贝初始化
string null_book = "99-999";    //拷贝初始化
string nines = string(100, '9); //拷贝初始化
```

+ 直接初始化时，实际上要求编译器使用普通的函数匹配的方法选择最匹配的构造函数；
+ 拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中，如需还可以类型转换；
+ 拷贝初始化通常使用拷贝构造函数，但也可以使用移动构造函数；

注意：

1.拷贝构造函数自己的参数必须是引用类型，如果其参数不是引用类型，则永远不会调用成功：为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，循环。

2.编译器可以绕过拷贝构造函数，直接创建对象，如将`string book = "999";`改写为`string book("999");`，虽然跳过拷贝/移动构造函数，但它们必须是存在且可访问的（非private）。

### 使用场景

+ 使用等号定义变量时；
+ 将对象作为实参传递给非引用类型的形参；
+ 从返回类型为非引用类型的函数返回一个对象；
+ 用花括号列表初始化一个数组或一个聚合类成员；
+ 容器insert或push时，使用拷贝初始化，emplace使用直接初始化；

### 什么时候需要自定义？

+ 如果一个类需要自定义析构函数，几乎可以肯定也需要自定义拷贝构造函数和拷贝赋值函数；
+ 需要拷贝操作的类也需要赋值操作，反之亦然，但不一定需要析构函数。

### 拷贝赋值

```c++
  // 考虑自赋值和异常安全
  HasPtr& HarPtr::operator=(const HasPtr &rhs) {
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    return *this;
  }
```

### swap管理资源

```c++
class HasPtr {
  friend void swap(HasPtr&, HasPtr&);
};
inline void swap(HasPtr& lhs, HasPtr &rhs) {
  using std::swap;
  // swap函数调用swap，而不是std::swap，避免成员有自定的swap函数
  // 优先匹配特定的版本
  // 异常安全
  swap(lhs.ps, rhs.ps);
  swap(lhs.i, rhs.i);
}
```

### 析构

内置类型没有析构函数，所以销毁内置类型成员时什么也不用做。隐式销毁一个内置指针类型成员不会销毁它指向的对象，智能指针具有析构函数，在析构是会自动销毁。

### 对象移动

在某些情况下，对象拷贝后立即销毁，此时移动而不是拷贝会大幅度提升性能。为了支持移动操作，引入新的引用类型：**右值引用**。

右值引用：必须绑定到右值的引用，通过`&&`来获得右值引用。右值引用只能绑定到一个即将销毁的对象，因此可以自由移动到另一个对象。

左值右值：

+ 一般而言，左值表达式表示的是一个对象的身份，右值表达式表示的是一个对象的值。
+ 左值拥有持久的状态，右值要么是字面值常量，要么是表达式求值过程中创建的临时变量（左值持久右值短暂）。
+ 变量是左值。

标准库容器、string和shared_ptr既支持拷贝也支持移动。IO类和unique_ptr可以移动不可拷贝。

### 标准库move函数：

`int &&rr2 = std::move(rr1);`

虽然不能直接将一个右值引用绑定到左值上，但可以显示转换，通过调用`move`标准化函数来获得绑定在左值上的右值应用。调用move以为着`rr1`可以被销毁或者重新赋值，**我们不能对移动后源对象的值做任何假设**。因此调用`std::move`是危险的，必须确定移动源对象没有其它用户。

不抛出异常的移动构造函数和移动赋值函数必须标记为`noexcept`。

+ 虽然移动操作通常不抛出异常，但抛出异常也是允许的；
+ 标准库容器能对异常时其自身的状态提供保障。