[harttle.land](https://harttle.land/tags.html#C++)  
[基本问题](https://blog.csdn.net/worldwindjp/article/category/1868017)  
[c++详细复习资料](https://github.com/huihut/interview)  
[c++分类教程](http://c.biancheng.net/cpp/biancheng/cpp/rumen/)  
[stl应用与实现](https://elloop.github.io/categories)

1. 写一个自动锁？
2. STL的allocate用来做什么？Map的Key有什么要求？必须重载\<运算符，不能重复。。
3. 四种智能指针的区别？智能指针如何实现的？
4. 你用过哪些c++库？（拓展思考c++工具）
5. 函数对象和函数指针？函数对象是重载了括号运算符的类的实例。
6. 谓词unary predicate和binary predicate？
7. 会写makefile吗？
8. 局部静态变量何时创建？C++11：内存地址早就占用了，但是会在你第一次执行到初始化的那行代码的时候初始化它，线程安全，可重入。
9. static和const：<https://www.cnblogs.com/xiezhw3/p/4354601.html>
10. 常量方法重载？
11. 运算符重载？实现一个重载赋值运算符？
12. [引用不占内存空间](https://stackoverflow.com/questions/1179937/how-does-a-c-reference-look-memory-wise)
13. 防御型程序设计
14. 指针占几个字节？
15. 实现一个不抛出异常的swap？
16. C++中的异常能完全避免吗？有声明方法可以实现异常安全？
17. [类数据成员的初始化顺序？](https://blog.csdn.net/yingzheng1983/article/details/52127870)

### 常见问题

#### auto_ptr能作为vector的元素吗？为什么？

不能拷贝

#### 如何初始化static和const成员？

通常在类外初始化static数据成员，但是 static const 的整型(bool，char，int，long)可以再类声明中初始化static const的其他类型也必须在类外初始化(包括整型的数组)。

#### 什么是RAII?如何保证对象在抛出异常时也能删除？

+ RAII：在类的构造函数获取资源，在类的析构函数释放资源，类的析构函数在异常出现时也会执行
+ 智能指针

#### 为什么需要private继承？

#### 如何实现单例模式？线程安全？DCLP是什么，有什么问题？

[单例](https://segmentfault.com/a/1190000003745529#articleHeader9)  
[c++与双重检查锁定](http://blog.jobbole.com/86392/)

#### 相等和等价的区别？哪些容器使用相等哪些使用等价？

相等是以`operator==`为基础，等价是以`operator<`为基础，如果`!(x<y) && !(y<x)`则等价。
通常，关联容器使用等价，而顺序容器使用相等。

#### 如何实现仿函数？为什么需要通过继承自`unary_funciton`或者binary_function实现仿函数？

function object就是重载了函数调用操作符 operator()的一个struct或者class；
所有内置一元仿函数均继承自unary_function，所有内置二元仿函数均继承自binary_function，
继承自unary_function和binary_function的仿函数可以成为“可配接“的仿函数。可配接的仿函数，能够与其他STL组件更”和谐“地协同工作。

#### 如果在构造函数或者析构函数抛出异常会发生什么？什么是栈展开？

1.构造函数抛异常：不会发生资源泄漏。假设在operator new()时抛出异常，那么将会因异常而结束此次调用，内存分配失败，不可能存在内存泄露。假设在别处(operator new() )执行之后抛出异常，此时析构函数调用，已构造的对象将得以正确释放，且自动调用operator delete()释放内存

2.析构函数抛异常：
可以抛出异常，但该异常必须留在析构函数；若析构函数因异常退出，情况会很糟糕(all kinds of bad things are likely to happen)
a、可能使得已分配的对象未能正常析构，造成内存泄露；
b、例如在对像数组的析构时，如果对象的析构函数抛出异常，释放代码将引发未定义行为。考虑一个对象数组的中间部分在析构时抛出异常，它无法传播，因为传播的话将使得后续部分不能正常释放；它也无法吸收，因为这违反了”异常中立“原则(异常中立，就是指任何底层的异常都会抛出到上层，也就相当于是异常透明的)。

3.抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。

#### 如何在const成员函数中赋值？

使用mutable去掉const成员函数的const性质。

const_cast和mutable的比较  
const_cast:  
1)强制去掉对象的const属性。  
2)缺点：对const对象，调用包含const_cast的const成员函数，属于未定义行为。  
mutable:  
1)使用场景：对可能要发生变化的成员前，加上存储描述符mutable。  
2)实质：对加了mutable的成员，无视所有const声明。  

为什么要有这种去除常量标志的需求？  
答：两个概念：物理常量性和逻辑常量性  
物理常量性：实际上就是常量。  
逻辑常量性：对用户而言是常量，但在用户不能访问的细节上不是常量。  

#### 两种常用的实现隐式类类型转换的方式是什么？如何避免隐式类型转换？

#### c++如何避免内存泄露？

这其实可以看做是一个编程风格的问题。

+ 使用RAII(Resource Acquisition Is Initialization,资源获取即初始化)技法，以构造函数获取资源(内存),析构函数释放。
+ 相比于使用原生指针，更建议使用智能指针，尤其是C++11标准化后的智能指针。
+ 注意delete和delete[]的使用方法。
+ 这是很复杂的一种情况，是关于类的copy constructor的。

#### stl中排序算法的实质是什么？

STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。

#### 指针和引用的区别

+ 指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。
+ 指针的值可以为空，且非const指针可以被重新赋值以指向另一个不同的对象。而引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系。
+ 作为参数的区别，返回的区别。
+ 引用是变量的别名，不占内存空间，不是对象，不能创建数组。
+ **引用是除指针外另一个可以产生多态效果的手段，一个基类的引用可以指向派生类的对象**。

#### 指针数组和数组指针

`int* a[10];`
`int (*a)[10];`

#### 指针函数和函数指针

`int* f();`：指针函数是返回类型是指针类型的函数；
`int (*f)();`：函数指针是指向函数入口地址的指针，一般用作调用函数和函数参数。

#### 二维动态数组申请和释放

```c++
size_t row, col;
//输入row和col的数值
int **MathTable = new int*[row];
for (int i = 0; i < row; i++)
    MathTable[i] = new int[col];

//code
for (int i = 0; i < row; i++)
    delete[] MathTable[i];
delete[]MathTable;
```

#### 进程，线程，协程

#### 编写类string的构造函数，析构函数，拷贝构造函数和赋值函数

#### static的作用

1. 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
2. 在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
3. 在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
4. 在类的static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝
5. 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量

#### 在c++程序中调用c编译器编译后的函数，为什么要加`extern c`?

C++语言支持函数重载，C语言不支持函数重载，函数被C++编译器编译后在库中的名字与C语言的不同。  
`void foo(int x, inty);`
该函数被C编译器编译后在库中的名字为:`_foo`，  
而C++编译器则会产生像:`_foo_int_int`之类的名字。  
为了解决此类名字匹配的问题，C++提供了C链接交换指定符号extern "C"。  

#### `#ifndef, #define, #endif`的作用

[防止头文件被重复包含：头文件全局变量可能重复定义](https://www.cnblogs.com/challenger-vip/p/3386819.html)

预处理功能包括三种：宏定义，文件包含，条件编译，以上为条件编译。

#### 动态链表和静态链表

普通用的链表是动态链表，静态链表是一个结构数组，每个元素带有一个指向下一元素的下标。

#### 高并发epoll

参考：
<https://segmentfault.com/a/1190000003745529#articleHeader22>

#### 使用shared_ptr需要注意声明？

#### c与c++的差别？c++是否完全兼容c？

参考：
<https://segmentfault.com/a/1190000003745529#articleHeader24>

#### c++内存对齐？

<https://segmentfault.com/a/1190000003745529#articleHeader25>

#### 为什么函数的参数入栈顺序是从右到左？

因为函数可以支持可变参数，如带有函数带有默认参数时，参数个数可以不一样，所以需要从右到左压栈，这样出栈顺序就是从第一个参数开始赋值。`printf`函数也是不定参数个数的。

#### 拷贝构造函数的用途？什么时候需要自定义拷贝构造函数？

c++在三种情况下使用拷贝构造函数：

+ 一个对象以值传递的方式传入函数体；
+ 一个对象以值传递的方式从函数返回；
+ 一个对象需要使用另一个对象进行初始化。

当类的数据成员需要动态分配内存空间时，不能依赖默认构造函数。

#### 函数模板特化与重载决议中的陷阱

#### virtual函数内声明为内联的吗？为什么？

通常情况是不能的。因为inline是编译期决定，以为着在编译期就需要用执行的动作替换被调用的函数本体。virtual是编译期决定，意味着知道运行期才知道运行的是哪个函数，二者通常是冲突的。然而有特例，则virtual不表现出多态时，则函数可以在编译期确定。

#### 哪些类型的对象不能作为union的成员？为什么？

标准规定，凡是具有non-trivial constructor、non-trivial destructor、non-trivial copy constructor、non-trivial assignment operator的class对象都不能作为union的成员。  
即是说，这个class的以上四种成员必须均经由编译器合成且该class无虚函数和虚基类。  
有这种限制是为了兼容C。

#### 实现一个不能在堆上创建的类？实现一个不能在栈上创建的类？实现一个不能被继承的类？

不能在堆上：将new重载为私有(使用`=delete`)，不能在栈上：将析构函数定义为私有，不能继承：使用final

#### 父类的virtual函数，如果子类覆盖它的函数不加virtual也能实现多态吗？

可以的，virtual修饰符会隐形继承的。

#### 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？

因为gets无法截断数组越界部分，会将所有输入都写入内存，这样越界部分就可能覆盖其他内容，造成程序崩溃。

#### c++语言中变量存储类型

auto, 默认动态局部变量
static：静态变量
extern：在一个文件内声明全局变量，在多文件程序声明外部变量
register：声明寄存器变量，为了提高效率，允许将局部变量放到CPU的寄存器中

#### overload, override, overwrite

overload：函数重载
override：虚函数覆盖，实习多态
overwrite：重写，子类重写父类非虚函数,从而屏蔽父类函数